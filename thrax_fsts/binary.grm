Zero = "0";
One = "1";
Bit = Zero | One;
EvenOnes = (One One);
OddOnes = One EvenOnes*;
export First = Optimize[Zero Zero* Bit* One One One One?];
export Second = Optimize[Zero Bit* One One One];
export Disagreements = Optimize[ (First - Second) | (Second - First) ];
export Triplets = Optimize[ Zero* (Zero* One One One One* Zero*)* ];
export NotPillars = Optimize[ OddOnes? (Zero Bit*)?];
export Oddlets = Optimize[ Zero* (OddOnes? Zero+)* OddOnes? ];
export WFlip = ((((Zero : One) | (One : Zero)) <2>) | (((Zero : Zero) | (One : One)) <1>) ) ((Zero : Zero One <.5>) | ((One : Zero) <.4>))+ (One : One <.5>);
export WeightedMultipath = ((Zero <1>) | (One <.23>) | (Bit <.5>)+ ) ((Zero <.32>) | (One <.32>) | (Bit <2>)*);
export WeightedMultipathOpt = Optimize[WeightedMultipath];


x = "01";
y = "10";
T = WeightedMultipath;
export T_out      = Project[     T,     'output'];  # erases input from T
export xT_out     = Project[ x @ T,     'output'];  # erases input x from x @ T
export Ty_in      = Project[     T @ y, 'input'];   # erases output y from T @ y
export xTy        =      x @ T @ y;
export exTye      = ("":x) @ T @ (y:"");  # erases input x & output y from x @ T @ y
export xT_out_opt = Optimize[xT_out];
export Ty_in_opt  = Optimize[Ty_in];
export exTye_opt  = Optimize[exTye];
